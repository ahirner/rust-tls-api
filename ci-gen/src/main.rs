use crate::actions::cargo_test;
use crate::actions::checkout_sources;
use crate::actions::checkout_sources_depth;
use crate::actions::rust_install_toolchain;
use crate::actions::RustToolchain;
use crate::ghwf::Env;
use crate::ghwf::Job;
use crate::ghwf::Step;
use crate::yaml::Yaml;
use crate::yaml::YamlWriter;
use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::Path;

mod actions;
mod ghwf;
mod yaml;

fn crates_list() -> Vec<String> {
    assert!(Path::new("./ci-gen").exists());
    let mut r = Vec::new();
    for p in fs::read_dir(".").unwrap() {
        let p = p.unwrap();
        if Path::new(&format!("{}/Cargo.toml", p.path().display())).exists() {
            r.push(p.path().file_name().unwrap().to_str().unwrap().to_owned());
        }
    }
    r.sort();
    assert!(r.len() > 3);
    r
}

fn steps(rt: &str, channel: RustToolchain) -> Vec<Step> {
    let mut r = vec![checkout_sources(), rust_install_toolchain(channel)];
    for c in crates_list() {
        let mut args = format!("--manifest-path={}/Cargo.toml", c);
        if c != "ci-gen" {
            args.push_str(&format!(" --no-default-features --features={}", rt));
        }
        let mut step = cargo_test(&format!("cargo test {}", c), &args);
        step.timeout_minutes = Some(5);
        r.push(step);
    }
    r
}

fn runtimes() -> Vec<&'static str> {
    vec!["runtime-tokio", "runtime-async-std"]
}

#[derive(PartialEq, Eq, Copy, Clone)]
struct Os {
    name: &'static str,
    ghwf: Env,
}

const LINUX: Os = Os {
    name: "linux",
    ghwf: Env::UbuntuLatest,
};
const MACOS: Os = Os {
    name: "macos",
    ghwf: Env::MacosLatest,
};
const _WINDOWS: Os = Os {
    name: "windows",
    ghwf: Env::WindowsLatest,
};

fn super_linter_job() -> Job {
    let mut steps = Vec::new();
    steps.push(checkout_sources_depth(Some(0)));
    steps.push(
        Step::uses("super-linter", "github/super-linter@v3")
            .env("VALIDATE_ALL_CODEBASE", "false")
            .env("DEFAULT_BRANCH", "master")
            .env("GITHUB_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            // Too many false positives
            .env("VALIDATE_JSCPD", "false")
            // Too many dull reports like how we should pluralise variable names
            .env("VALIDATE_PROTOBUF", "false"),
    );
    Job {
        id: "super-linter".to_owned(),
        name: "super-linter".to_owned(),
        runs_on: LINUX.ghwf,
        steps,
        ..Default::default()
    }
}

fn rustfmt_job() -> Job {
    let os = LINUX;
    let mut steps = Vec::new();
    steps.push(checkout_sources());
    Job {
        id: "rustfmt-check".to_owned(),
        name: "rustfmt check".to_owned(),
        runs_on: os.ghwf,
        steps,
        ..Default::default()
    }
}

fn jobs() -> Yaml {
    let mut r = Vec::new();
    for rt in runtimes() {
        for &channel in &[
            RustToolchain::Stable,
            RustToolchain::Beta,
            RustToolchain::Nightly,
        ] {
            for &os in &[LINUX, MACOS] {
                if channel == RustToolchain::Beta && os == MACOS {
                    // skip some jobs because macos is expensive
                    continue;
                }
                r.push(Job {
                    id: format!("{}-{}-{}", rt, os.name, channel),
                    name: format!("{} {} {}", rt, os.name, channel),
                    runs_on: os.ghwf,
                    steps: steps(rt, channel),
                    ..Default::default()
                });
            }
        }
    }

    r.push(rustfmt_job());
    r.push(super_linter_job());

    Yaml::map(r.into_iter().map(Job::into))
}

fn main() {
    let yaml = Yaml::map(vec![
        ("on", Yaml::list(vec!["push", "pull_request"])),
        ("name", Yaml::string("CI")),
        ("jobs", jobs()),
    ]);

    let mut writer = YamlWriter::default();
    writer.write_line(&format!(
        "# @generated by {}, do not edit",
        env!("CARGO_PKG_NAME")
    ));
    writer.write_line("");
    writer.write_yaml(&yaml);
    File::create(".github/workflows/ci.yml")
        .unwrap()
        .write_all(writer.buffer.as_bytes())
        .unwrap();
}
